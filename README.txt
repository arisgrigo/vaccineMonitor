ΑΜ: 1115201800036
Ονομ/νυμο: Άρης Γρηγορόπουλος

Υλοποίησα την άσκηση σε C.
Έχω υλοποιήσει κάθε ζητούμενο της άσκησης (Α και Β μέρος)

~~~~~~~~
Μέρος Α)
Το πρόγραμμά μου αποτελείται από 6 αρχεία .c:
main.c
citizen.c
country.c
skipList.c
bloomFilter.c
queries.c

και 5 αρχεία .h:
citizen.h
country.h
skipList.h
bloomFilter.h
queries.h

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Σύντομη περιγραφή κάθε αρχείου:
main: Ελέγχει το input του χρήστη και κάνει parse το αρχείο που περιέχει τα citizen records. Έπειτα δέχεται input από τον χρήστη για να καλέσει το κατάλληλο query.

citizen: Περιέχει την δομή που κρατάει τα στοιχεία του κάθε citizen (ένα node για κάθε διαφορετικό citizenID). Περιέχει και όλες τις απαραίτητες συναρτήσεις για τον διαχειρισμό αυτής της δομής.

country: Περιέχει την δομή που κρατάει τα στοιχεία της κάθε χώρας (ένα node για κάθε διαφορετικό country). Περιέχει και όλες τις απαραίτητες συναρτήσεις για τον διαχειρισμό αυτής της δομής.

skipList: Περιέχει την δομή της SkipList, την δομή του node από τα οποία αποτελείται κάθε skipList, και τη δομή του date. Περιέχει και όλες τις απαραίτητες συναρτήσεις για τον διαχειρισμό αυτών των δομών.

bloomFilter: Περιέχει την δομή του BloomFilter (ένα bloom filter για κάθε διαφορετικό virus). Περιέχει και όλες τις απαραίτητες συναρτήσεις για τον διαχειρισμό αυτής της δομής.

queries: Περιέχει την υλοποιήση κάθε query (πχ. /vaccineStatus, /populationStatus etc.).


Το πρόγραμμα χρησιμοποιεί επίσης τις εξής βιβλιοθήκες:
stdio.h
stdlib.h
string.h
time.h (για την παραγωγή τυχαίων αριθμών, και τη λήψη της σημερινής ημερομηνίας για το /vaccinateNow)
unistd.h (για τον έλεγχο των arguements που δέχεται το πρόγραμμα με getopt)
ctype.h  ^

~~~~~~~~~~~~~~~~~~~~~~~~
Οδηγίες για το makefile:
$ make run			που κάνει compile τα αρχεία και δημιουργεί το executable vaccineMonitor
$ make clean 		για διαγραφή του executable vaccineMonitor

~~~~~~~~~~~~~~~~~~~~
Περιγραφή των δομών:

Το πρόγραμμα συνολικά, χρησιμοποιεί τις εξής δομές:

(όπου αναφέρομαι σε head pointer, εννοώ τον pointer που χρησιμοποιεί η main για την προσπέλαση και τον διαχειρισμό κάθε δομής)

citizen που είναι μία απλά συνδεδεμένη λίστα, στην οποία ο head pointer δείχνει πάντα στο node που προστέθηκε τελευταίο στη λίστα.
Κάθε node της citizenList περιέχει όλα τα στοιχεία που αφορούν έναν συγκεκριμένο citizen (id, firstName, lastName, country, age).
Το country είναι pointer που δείχνει στο κατάλληλο node μέσα στο countryList (για να μην υπάρχει data duplication).
Έπισης περιέχει το citizen* next, που δείχνει στο αμέσως προηγούμενο node της λίστας.

country που είναι μία απλά συνδεδεμένη λίστα, στην οποία ο head pointer δείχνει πάντα στο node που προστέθηκε τελευταίο στη λίστα.
Κάθε node της countryList περιέχει μόνο το όνομα της χώρας και έναν pointer country* next, που δείχνει στο αμέσως προηγούμενο node της λίστας.

skipList που είναι μία απλά συνδεδεμένη λίστα, στην οποία ο head pointer δείχνει πάντα στο node που προστέθηκε τελευταίο στη λίστα.
Κάθε node αποτελείται από το όνομα της skipList(virus), από έναν pointer στο headNode(1o στοιχείο μέσα στη λίστα του κάθε στοιχείου skipList), από το maxLevel (που είναι hard-coded ως 23, αφού log(worldpopulation) ~ 23),
από έναν pointer skipList* upperList (που δείχνει στο αμέσως πάνω level του κάθε skipList), από έναν pointer skipList* lowerList (που δείχνει στο αμέσως κάτω level του κάθε skipList)
και τέλος, έναν pointer skipList* nextList (που δείχνει στο επόμενο skipList, δηλαδή σε skipList που αφορά διαφορετικό virus)
Η δομή skipList ουσιαστικά αποτελεί μία λίστα απο skip lists, όπου κάθε node είναι ένα skip list για έναν συγκεκριμένο virus.

Όπως αναφέρθηκε προηγουμένος, κάθε skipList αποτελείται και από ενα pointer στο headNode.
Η δομή του node αποτελείται από ένα citizenID (για έυκολη προσπέλαση),
από έναν pointer date, που δείχνει στο date στο οποίο εμβολιάστηκε ο citizen του node (η πληροφορία του date φυλλάσεται μόνο στο πιο κάτω επίπεδο της κάθε skip list, για να μην υπάρχει data duplication. Στα πιο πάνω επίπεδα, η date* δείχνει στο date του αντίστοιχου node του πιο κάτω επιπέδου),
από το citizenCheck*, που είναι pointer που δείχνει στο κατάλληλο node μέσα στο citizenList, και από εκεί έχει πρόσβαση σε όλα τα δεδομένα του citizen που βρίσκεται "μέσα" στο skip list,
από έναν pointer node* nextNode, που δείχνει στο επόμενο node της λίστας,
και από έναν pointer node* downNode, που δείχνει στον αμέσως πιο κάτω node, αν το node βρίσκεται σε skip list με πολλαπλά επίπεδα. (ώστε να γίνεται γρήγορη προσπέλαση όταν αναζητούμε έναν συγκεκριμένο citizen μέσα σε skip list πχ.)

bloomFilter που είναι μία απλά συνδεδεμένη λίστα, στην οποία ο head pointer δείχνει πάντα στο node που προστέθηκε τελευταίο στη λίστα.
Κάθε bloomFilter αποτελείται από το όνομα του bloomFilter(virus), από ένα dynamic array int* bitArray (που είναι ο πίνακας στον οποίο κρατάμε τα bits, που αρχικά είναι όλα 0)
και από έναν pointer bloomFilter* next (που δείχνει στο επόμενο bloomFilter, δηλαδή σε bloomFilter που αφορά διαφορετικό virus)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Επιπλέον πληροφορίες για την υλοποιήση των δομών που ζητούσε η άσκηση:

bloomFilter:
Initialization του bloomFilter:
Για την αρχικοποίηση του κάθε bloomFilter, περνάμε τον αριθμό των bytes από τα οποία αποτελείται (input του χρήστη) και το όνομα του virus στον οποίον αναφέρεται το bloom filter.
Αφού το bloomFilter αποτελείται από έναν πίνακα int, διαιρούμε τα bytes δία 4 (αφού το κάθε int αποτελείται από 4 bytes). Το αποτέλεσμα, είναι το πόσες "θέσεις" θα δεσμεύσουμε στη μνήμη για τον πίνακα κάθε bloomFilter.
(πχ αν περάσουμε 24 bytes, ο πίνακας int* bitArray θα αποτελείται απο 24/4=6 θέσεις.
Έπειτα αρχικοποιείται κάθε θέση στο bitArray ώστε να είναι 0.

"Εισαγωγή" citizen σε bloomFilter:
Άφου πάρουμε τα 16 νούμερα από τα hash functions που μας δώθηκαν, χρησιμοποιούμε την συνάρτηση setBloomBit για να θέσουμε τα κατάλληλα bit του bloomFilter σε 1.
Αν πχ. θέλουμε να θέσουμε το 512ο bit του bloomFilter σε 1, η setBloomBit κάνει το εξής:
Βρίσκει την σωστή θέση στο bloomFilter κάνοντας arrayIndex = 512/32			(32 αφού κάθε θέση στον πίνακα είναι 4 bytes = 32 bits)
Βρίσκει το συγκεκριμένο bit μέσα στο index κάνοντας bitPos = 512%32
και έπειτα, με χρήση flag που κάνει shift στη σωστή θέση, με τον bitwise operator |, θέται το bit σε 1.

Με όμοια διαδικασία γίνεται έλεγχος για το εάν ένα bit είναι 0 ή 1.


skipList:
Το κάθε skipList αποτελείται από τουλάχιστον μία λίστα, οπού κάθε node της δείχνει προς ένα node του citizenList.
Η skipList μπορεί να έχει πολλαπλά επίπεδα, ίσα με maxLevel(=23). (αν κάποιος επιθυμεί να αλλάξει το maxLevel, αυτό ορίζεται μέσα στη συνάρτηση skipListInit, και είναι ίδιο για κάθε skipList.)
Με την υλοποιήση μου, η κάθε skipList απλά περιέχει το headNode της λίστας των (μη)εμβολιασμένων, για κάθε επίπεδο.
Οπότε, αν πχ, ψάχνουμε τον citizen με id 1624 σε συγκεκριμένο skipList, το πρόγραμμα, θα βρει το skipList αυτό, θα πάει στο πιο πάνω επίπεδό του, και θα χρησιμοποιήσει τον pointer headNode αυτού του επιπέδου.
Χρησιμοποιώντας τον pointer next του headNode, θα αρχίσει να ψάχνει το επίπεδο αυτό, μέχρι να βρει μεγαλύτερο citizen id από το 1624 ή μέχρι να βρει το τέλος της λίστας.
Σε αυτό το σημείο, χρησιμοποιώντας τον pointer downNode, θα "κατέβει" στο αμέσως πιο κάτω επίπεδο, στο αντίστοιχο node, και θα συνεχίσει την ίδια διαδικασια, μέχρι να το βρει.

Τα list από τα οποία αποτελείται το κάθε skipList είναι ταξινομημένα με βάση το citizenID.
Η λίστα που κρατάει όλα τα skipLists (δηλαδή τα skipLists για κάθε διαφορετικό ιό), δεν είναι ταξινομημένη αλφαβητικά, αλλά δείχνει πάντα στο τελευταίο skipList που προστέθηκε στη λίστα, το οποίο με τη σειρά του δείχνει στο skipList που προστέθηκε πριν από το ίδιο κ.ο.κ.

Το αν θα προστεθεί νέο επίπεδο σε skipList (εφόσον δεν έχει φτάσει το maxLevel), κατά την εισαγωγή νέου στοιχείου στη λίστα, είναι toin coss (50% πιθανότητα)

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Πληροφορίες για την υλοποιήση των queries:

Για τις ερωτήσεις /populationStatus και /popStatusByAge, είναι υποχρεωτικό να δωθεί date range από τον χρήστη, το οποίο πρέπει αυστηρά, να είναι της μορφής dd-mm-yyyy.
Κάθε query ελέγχει αν το input του user είναι σωστό.
Για παράδειγμα στην εντολή /vaccinateNow, περιμένει αμέσως μετά από την εντολή να δει έναν integer (το citizenID), οπότε αν δει κάτι διαφορετικό από int, κάνει print error.
Ο έλεγχος γίνεται αυστηρά με βάση τα πεδία που δώθηκαν για κάθε εντολή από την εκφώνηση της άσκησης.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Πληροφορίες για την υλοποιήση της main:

Η main, αρχικά ελέγχει αν τα arguments που δέχτηκε από τον χρήστη είναι σωστά (δεν έχει σημασία αν το -b ή το -c είναι πρώτο, αλλά το πλήθος των argument είναι αυστηρά 5)
και έπειτα ανοίγει το input file. Για το parsing, χρησιμοποιεί το citizenList, το countryList, το vaccinatedSkipList, το not_vaccinatedSkipList και το bloomList.
Κάθε ένα από τα παραπάνω, αποτελεί pointer στο head node της αντίστοιχης δομής (το head node δείχνει πάντα στο στοιχείο που προστέθηκε τελευταίο στη λίστα, οπότε η εισαγωγή ενός στοιχείου γίνεται σε Ο(1)).
Το citizenList είναι η λίστα που περιέχει τα στοιχεία κάθε citizen, το countryList είναι η λίστα που περιέχει τα στοιχεία κάθε country,
το vaccinatedSkipList και το not_vaccinatedSkipList είναι οι λίστες που περιέχουν τα skipLists για κάθε ιό (ένα για τους εμβολιασμένους πολίτες και ένα για τους όχι)
και το bloomList είναι η λίστα που περιέχει το bloomFilter για κάθε ιό.

Για κάθε γραμμή, γίνται έλεγχος για το αν το συγκεκριμένο citizenID υπάρχει στο citizenList, και αν υπάρχει, γίνεται έλεγχος για το αν η εγγραφή είναι consistent με τις προηγούμενες.
Αλλιώς, γίνται ο standard έλεγχος για το αν η εγγραφή είναι έγκυρη (πχ. αν η ημερομηνία μιας εγγραφής έχει ως ημερομηνία εμβολιασμού 50-15-2068 θεωρείται όχι έγκυρη και προσπερνιέται)
Αν η εγγραφή περάσει όλους τους ελέγχους και θεωρηθεί έγκυρη, γίνεται κατάλληλη ενημέρωση όλων των δομών που αφορούν την εγγραφή αυτή.
Αφού τελειώσει η διαδικασία του parsing, η main μπαίνει σε ένα while loop, για τις ερωτήσεις, και το πρόγραμμα κλείνει μόνο αν ο user βάλει ως input "/exit". Όταν το πρόγραμμα λάβει το "/exit" ελευθερώνει όλων τον χώρο που είχε δεσμευτεί για τις δομές.
Με δικούς μου ελέγχος με valgrind, όλα τα heap blocks ελευθερώνονται χωρίς leaks ή προβλήματα.

~~~~~~~~~~~~~~~~~
Data Duplication:

Στο πρόγραμμά μου, προσπάθησα να έχω όσων το δυνατό μικρότερο data duplication μπορούσα.
Η μνήμη για τα στοιχεία κάθε citizen, βρίσκονται μόνο μέσα στο citizenList, και όλες οι υπόλοιπες δομές δείχνουν σε αυτή τη λίστα αν χρησιμοποιούν κάποιο στοιχείο ενός citizen.
Σε αυτό, αποτελεί εξαίρεση το citizenID, αφού κάθε node του skipList περιέχει το citizenID μέσα στο ίδιο το node (αντί να το παίρνει απο το citizenCheck, που είναι ο pointer προς τον citizen).
Αυτό, τεχνικά, αποτελεί data duplication, αλλά αφού επιτράπηκε από τους instructors στο piazza, αποφάσισα να το κρατήσω.
Η μνήμη για την ονομασία κάθε country, βρίσκεται αποκλειστικά στο countryList, και όλες οι υπόλοιπες δομές δείχνουν σε αυτή τη λίστα αν χρησιμοποιούν το όνομα ενός country.
Το date εμβολιασμού κάθε node βρίσκεται μόνο στο πιο κάτω επίπεδο της skipList, οπότε και εκεί δεν υπάρχει data duplication (οι πιο πάνω λίστες, δείχνουν στο date που βρίσκεται στην πιο κάτω λίστα, αντί να δεσμεύουν μνήμη για το ίδιο date)
Το μόνο άλλο σημείο στο οποίο υπάρχει data duplication είναι στα ονόματα (virus) κάθε skipList και bloomFilter, αφού δεν έχω δομή που να κρατάει τα ονόματα των viruses. Αυτό το θεώρησα αποδεκτό για τον ίδιο λόγο που ήταν και αποδεκτό το data duplication όσο αφορά στο citizenID του κάθε node των skipList)


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Αιτιολόγηση μερικών επιλογών μου:

Ο λόγος που χρησιμοποιήσα απλή λίστα για την δομή που περιέχει τους citizens (αντί για πχ. hash table) είναι επειδη:
1) έχει άμεση εισαγωγή (αφού οι pointers για κάθε δομή δείχνουν στο τελευταίο στοιχείο, η εισαγωγή γίνεται σε Ο(1))
2) είναι απλή δομή που λαμβάνει λιγότερο χρόνο στη μνήμη, κάτι που μου επέτρεψε να δώσω περισσότερη προσοχή στις δομές που ζητούσε η άσκηση (skipList και bloomFilter)

Η λογική μου ήταν ότι το μεγαλύτερο "φόρτο" της άσκησης, είναι το αρχικό parsing του input file, και εφόσον το πρόγραμμα μου τρέχει ικανοποιητικά γρήορα για ~5.000 εγγραφές (και αξιότιμα ακόμα και για ~10.000), δε θεώρησα αναγκαίο να χρησιμοποιήσω μία πιο περίπλοκη δομή.
Με δικές μου δοκιμές, για 5.000-10.000 εγγραφές το πρόγραμμα εκτελεί το parsing σε περίπου ένα δευτερόλεπτο, ενώ αρχίζει να αργεί για εγγραφές μεγαλύτερες των 50000.
Με δοκιμές μου έβγαλα οτι για 50.000 εγγραφές παίρνει περίπου 1 λεπτό, ενώ για 100.000 παίρνει περίπου 3-5 λεπτά, κάτι που θεωρείσα αποδεκτό, με βάση όσα είχαν πει και οι instructors στο piazza.

Οι λίστες που υλοποιήσα είναι μονά συνδεδεμένες (με εξαίρεση τις λίστες των skipList, που δείχνουν στις πιο πάνω και πιο κάτω λίστες) για εξοικονόμηση χώρου.
Δεν έκρινα αναγκαίο το να είναι διπλά συνδεδεμένες οι λίστες, αφού η ταχύτητα του προγράμματος είναι ήδη καλή.

~~~~~~~~
Μέρος Β)
~~~~~~~~

Το bashScript μου δημιουργεί το inputFile.txt γραμμή-γραμμή.
Τα strings για το firstName και lastName δημιουργούνται τυχαία και έχουν τυχαίο μήκος (από 3 έως 16 χαρακτήρες)
Για τις χώρες και τα viruses, το script διαλέγει μια τυχαία σειρά από τα αρχεία countryFile και virusesFile αντίστοιχα, για να εισαχθούν στο record.
Οι ημερομηνίες είναι της μορφής dd-mm-yyyy, με επιτρεπτό range για τον χρόνο να έιναι 1961-2021
Αν το duplicatesAllowed είναι ίσο με 1, και δημιουργηθεί duplicate record, τότε υπάρχει ~20% πιθανότητα * το record αυτό να είναι consistent.
Δηλαδή υπάρχει ~20% πιθανότητα το νεο record να έχει ίδιο id, όνομα, επώνυμο, χώρα και ηλικεία.
Επίσης, για την βοήθεια της προφορικής εξέτασης, το έχω κάνει ώστε κάθε 20η γραμμή να είναι duplicate, και σχεδόν σίγουρα consistent.
(σχολιασμένο στον κώδικα έχω και 2η μέθοδο για να κάνω σίγουρο το ότι θα υπάρχει valid duplicate record, που χρησιμοποιεί τυχαίο νούμερο, αντί για το ντιτερμενιστικό προηγούμενο τρόπο)

* η πιθανότητα είναι περίπου 20%, γιατί ακόμα και αν το dice roll είναι επιτυχές (1/5), υπάρχει πιθανότητα το πρόγραμμα να διαλέξει virus από το virusesFile, που να είναι ίδιο με αυτό του προηγούμενου record, κάτι που καθιστά το νέο record incsonsistent. Επέλεξα να κρατήσω αυτό το "feature" γιατί παράγει πιο "ενδιαφέροντα" αρχεία για να κάνει parse το κύριο πρόγραμμα.

Το script παίρνει περίπου μισό λεπτό για να δημιουργήσει 1000 εγγραφές, και περίπου 3 λεπτά για να δημιουργήσει 5.000 (οι χρόνοι είναι από το laptop μου, καθώς λόγω των προβλημάτων με τους servers του τμήματος, δεν πρόλαβα να κάνω επαρκές testing σε αυτούς)

Εντολή για να τρέξει το testFile.sh:
./testFile.sh countryFile virusesFile [αριθμός record] [1 ή 0]
πχ:
./testFile.sh countryFile virusesFile 1000 1
